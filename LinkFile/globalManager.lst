C51 COMPILER V9.59.0.0   GLOBALMANAGER                                                     04/25/2019 10:10:20 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE GLOBALMANAGER
OBJECT MODULE PLACED IN .\bin\globalManager.obj
COMPILER INVOKED BY: G:\Keil_v5\C51\BIN\C51.EXE globalManager\globalManager.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEN
                    -D PRINT(.\LinkFile\globalManager.lst) TABS(2) OBJECT(.\bin\globalManager.obj)

line level    source

   1          #include "globalManager.h"
   2          //全局管理全局对象
   3          static  GlobalManager this;
   4          /**
   5           * @brief 上电的时候初始化整个单片机所有的参数函数
   6           */
   7          void g_initSystemParameter()
   8          {
   9   1          //定时器中断初始化
  10   1          interrupt1Init();
  11   1          //初始化串口
  12   1          uartInit();
  13   1          //函数的初始化
  14   1          this.controlMotor1StatusFunc=controlMotor1Status;
  15   1          this.controlMotor2StatusFunc=controlMotor2Status;
  16   1          this.handleSensorDataFunc=handleSensorData; 
  17   1          this.handleSendSmsInfoFunc=handleSendSmsInfo;
  18   1          this.handleControlMagnetFunc=handleControlMagnet;
  19   1      }
  20          const GlobalManager g_getGlobalManagerObj()
  21          {
  22   1        return this;
  23   1      }
  24          static const bool controlMotor1Status(const MotorStatus status)
  25          {
  26   1          switch(status){
  27   2            case Move_Up:               //正转
  28   2              Motor1ControlTurn(true,MOTOR1CIRCLENUMBER);
  29   2                    //todo把记录写入EEPROM
  30   2              return true;
  31   2            case Move_Down:              //反转
  32   2              Motor1ControlTurn(false,MOTOR1CIRCLENUMBER);
  33   2                    //todo把记录写入EEPROM
  34   2              return true;
  35   2            case Move_Stop:             //停止
  36   2              Motor1ControlStop();
  37   2              return true;
  38   2            default:
  39   2              return false;
  40   2          } 
  41   1      }
  42          static const bool controlMotor2Status(const MotorStatus status)
  43          {
  44   1          switch(status){
  45   2            case Move_Up:               //正转
  46   2              Motor2ControlTurn(true,MOTOR2CIRCLENUMBER);
  47   2              return true;
  48   2            case Move_Down:              //反转
  49   2              Motor2ControlTurn(false,MOTOR2CIRCLENUMBER);
  50   2              return true;
  51   2            case Move_Stop:             //停止
  52   2              Motor2ControlStop();
  53   2              return true;
  54   2            default:
C51 COMPILER V9.59.0.0   GLOBALMANAGER                                                     04/25/2019 10:10:20 PAGE 2   

  55   2              return false;
  56   2          } 
  57   1      }
  58          const bool handleSensorData(void)
  59          {
  60   1          uint8_t adcValue=0;
  61   1          DHT11Data dh11Data;
  62   1          memset(&dh11Data,0,sizeof(DHT11Data));
  63   1          adcValue=getAdcValue(Channel1);//获取光敏传感器的数值(未转换公式)
  64   1          adcValue=getAdcValue(Channel2);//获取雨滴传感器的数值(未转换公式)
  65   1          adcValue=getAdcValue(Channel3);//获取风速传感器的数值(未转换公式)
  66   1          //todo 处理传感器的值与阈值判断
  67   1          //光敏传感器等
  68   1      //    handleSendSmsInfo();
  69   1        
  70   1          dh11Data=DHT11_receive();
  71   1          sendThresholdToPhone(&dh11Data.RH);   
  72   1          sendThresholdToPhone(&dh11Data.TH);   
  73   1          return false;
  74   1      }
  75          static const bool handleSendSmsInfo(void)
  76          {
  77   1        //todo发送gsm的信息
  78   1      //  uint8_t adcData=getAdcValueDisplay();
  79   1      //  sendThresholdToPhone(&adcData);
  80   1        return true;
  81   1      }
  82          void g_delay(const uint32_t one_10us)
  83          {
  84   1        if(!one_10us)
  85   1          return;
  86   1        g_EndCount=one_10us;
  87   1        g_CurrentCount=0;
  88   1        forever{
  89   2          if(g_CurrentCount>=g_EndCount)
  90   2            break;
  91   2        }
  92   1      }
  93          static void  interrupt1Init()
  94          {
  95   1        EA = OPEN;
  96   1        TMOD = 0x11;
  97   1        ET0 = OPEN;
  98   1        //10 us
  99   1        TH0=(65536-10)/256;
 100   1        TL0=(65536-10)%256;
 101   1        TR0=OPEN;
 102   1      }
 103          static void  uartInit()
 104          {
 105   1        //设置9600的波特率
 106   1      #ifdef RATE12
 107   1          RCAP2L=0xD9;
 108   1          RCAP2H=0xFF;
 109   1          T2CON=0x34;
 110   1          SCON=0x50;
 111   1          ES=OPEN;
 112   1          EA=OPEN;
 113   1      #else
                  PCON &= 0x7F;
                  SCON = 0x50;
                  TMOD &= 0x0F; 
C51 COMPILER V9.59.0.0   GLOBALMANAGER                                                     04/25/2019 10:10:20 PAGE 3   

                  TMOD |= 0x20;
                  TL1 = 0xFD;
                  TH1 = 0xFD;
                  ET1 = 0;
                  TR1 = OPEN; 
                  ES  = OPEN;
              #endif
 124   1      }
 125          static const bool handleControlMagnet(const bool isOpen)
 126          {
 127   1        //电磁铁控制开关
 128   1        if(isOpen){
 129   2            MagnetSwitch=OPEN;//高电平开
 130   2        }else{
 131   2            MagnetSwitch=CLOSE; //低电平关闭    
 132   2        }
 133   1        return true;
 134   1      }
 135          /*******************************************************************************
 136          * 函 数 名         : timeout
 137          * 函数功能       :定时器中断触发
 138          * 输    入         : 无
 139          * 输    出         : 无
 140          *******************************************************************************/
 141          void timeout(void) interrupt 1
 142          {
 143   1        //10 us
 144   1        TH0=(65536-10)/256;
 145   1        TL0=(65536-10)%256;
 146   1      
 147   1        g_CurrentCount++;
 148   1        ADC_CLOCK=~ADC_CLOCK;//给adc模块发送方波
 149   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    306    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     19       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
