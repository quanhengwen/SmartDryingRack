C51 COMPILER V9.59.0.0   GSMMANAGER                                                        04/25/2019 11:25:36 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE GSMMANAGER
OBJECT MODULE PLACED IN .\bin\gsmManager.obj
COMPILER INVOKED BY: G:\Keil_v5\C51\BIN\C51.EXE gsmManager\gsmManager.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRIN
                    -T(.\LinkFile\gsmManager.lst) TABS(2) OBJECT(.\bin\gsmManager.obj)

line level    source

   1          #include "gsmManager.h"
   2          #define Buf_Max       70  //串口1缓存长度
   3          uint8_t First_Int = 0;
   4          xdata uint8_t Uart1_Buf[Buf_Max];
   5          const bool sendThresholdToPhone(const uint8_t *content)
   6          {
   7   1        bool ret;
   8   1        
   9   1        ret = UART1_Send_AT_Command(content," ",1,50);//测试通信是否成功
  10   1        if(!ret)
  11   1        {
  12   2          return false;
  13   2        }
  14   1      //  
  15   1      //  ret = UART1_Send_AT_Command("AT+CPIN?","READY",2,50);//查询卡是否插上
  16   1      //  if(!ret)
  17   1      //  {
  18   1      //    return false;
  19   1      //  }
  20   1        //todo 发送信息到手机去
  21   1      //  ret = UART1_Send_AT_Command(phone,"OK",2,50);//拨号
  22   1      //  if(!ret)
  23   1      //  {
  24   1      //    return false;
  25   1      //  }
  26   1        return true;
  27   1      }
  28          static const bool UART1_Send_AT_Command(uint8_t *sendData,uint8_t *backData,uint8_t wait_time, uint16_t in
             -terval_time)       
  29          {
  30   1        uint8_t count=0;
  31   1      
  32   1        CLR_Buf();  //先清空接收buffer
  33   1        while(count < wait_time)                    
  34   1        {
  35   2          UART1_Send_Command(sendData);//把指令发出去 会自动添加\r\n后缀的
  36   2          g_delay(interval_time*100);
  37   2          if(Find(backData))            //查找需要应答的字符
  38   2          {
  39   3            return true;
  40   3          }
  41   2          count++;
  42   2        }
  43   1        return false;
  44   1      }
  45          /*******************************************************************************
  46          * 函数名 : CLR_Buf
  47          * 描述   : 清除串口2缓存数据
  48          * 输入   : 
  49          * 输出   : 
  50          * 返回   : 
  51          * 注意   : 
  52          *******************************************************************************/
  53          static void CLR_Buf(void)
C51 COMPILER V9.59.0.0   GSMMANAGER                                                        04/25/2019 11:25:36 PAGE 2   

  54          {
  55   1        uint8_t count;
  56   1        for(count=0;count<Buf_Max;count++)      //将缓存内容清零
  57   1        {
  58   2          Uart1_Buf[count] = 0x00;
  59   2        }
  60   1          First_Int = 0;              //接收字符串的起始存储位置
  61   1      }
  62          /**********************************
  63          发送命令
  64          **********************************/
  65          static void UART1_Send_Command(uint8_t *s)
  66          {
  67   1        CLR_Buf(); 
  68   1        while(*s)//检测字符串结束符
  69   1        {
  70   2          UART1_SendData(*s++);//发送当前字符
  71   2        }
  72   1      //  UART1_SendData(0x0D);
  73   1      //  UART1_SendData(0x0A);
  74   1      }
  75          /*----------------------------
  76          UART1 发送串口数据
  77          -----------------------------*/
  78          static void UART1_SendData(uint8_t dat)
  79          {
  80   1        ES=0;     //关串口中断
  81   1        SBUF=dat;     
  82   1        while(TI!=1); //等待发送成功
  83   1        TI=0;     //清除发送中断标志
  84   1        ES=1;     //开串口中断
  85   1      }
  86          /*******************************************************************************
  87          * 函数名 : Find
  88          * 描述   : 判断缓存中是否含有指定的字符串
  89          * 输入   : 
  90          * 输出   : 
  91          * 返回   : unsigned char:1 找到指定字符，0 未找到指定字符 
  92          * 注意   : 
  93          *******************************************************************************/
  94          
  95          static const bool Find(uint8_t *content)
  96          { 
  97   1        ES = 0;  //改进程序
  98   1        if(strstr(Uart1_Buf,content)!=NULL)
  99   1        {
 100   2          ES = 1;
 101   2          return true;
 102   2        } 
 103   1        else
 104   1        {
 105   2          ES = 1;
 106   2          return false;
 107   2        } 
 108   1      }
 109          
 110          /********************* UART1中断函数************************/
 111          void UART1_ISR (void) interrupt 4
 112          {
 113   1        if (RI)
 114   1        {
 115   2          RI = 0;                           //清除RI位
C51 COMPILER V9.59.0.0   GSMMANAGER                                                        04/25/2019 11:25:36 PAGE 3   

 116   2          Uart1_Buf[First_Int] = SBUF;      //将接收到的字符串存到缓存中
 117   2          First_Int++;                    //缓存指针向后移动
 118   2          if(First_Int >= Buf_Max)          //如果缓存满,将缓存指针指向缓存的首地址
 119   2          {
 120   3            First_Int = 0;
 121   3          }
 122   2        }
 123   1        if (TI)
 124   1        {
 125   2          TI = 0;                          //清除TI位
 126   2        }
 127   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    271    ----
   CONSTANT SIZE    =      2    ----
   XDATA SIZE       =     70    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5      16
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
